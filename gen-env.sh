#!/bin/bash
# if error, exit with a failure return code
set -eo pipefail

# -----------------------------------------------
# Argument parsing
# -----------------------------------------------
# Supports an optional --exclude flag that accepts a comma-delimited list of
# directory paths to exclude from processing. Example:
#   ./gen-env.sh --exclude "shared/env,shared/deploy"
# Paths are treated as relative to the project root. The flag can be provided as
#   --exclude dir1,dir2      or   --exclude="dir1,dir2"

EXCLUDE_PATHS=""

# Simple argument parser
while [[ $# -gt 0 ]]; do
    case "$1" in
        --exclude)
            EXCLUDE_PATHS="$2"
            shift 2
            ;;
        --exclude=*)
            EXCLUDE_PATHS="${1#*=}"
            shift 1
            ;;
        *)
            echo "Unknown option: $1" >&2
            exit 1
            ;;
    esac
done

# Convert comma-separated list to array
IFS=',' read -r -a EXCLUDE_DIRS <<< "$EXCLUDE_PATHS"

# Build find(1) exclusion arguments
FIND_EXCLUDE_ARGS=()
for dir in "${EXCLUDE_DIRS[@]}"; do
    # Trim whitespace and trailing slashes
    dir="$(echo "$dir" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')"
    dir="${dir%/}"
    if [[ -n "$dir" ]]; then
        # Exclude everything under the directory
        FIND_EXCLUDE_ARGS+=( -not -path "./$dir/*" )
    fi
done

ENV_GEN_FILE=".env"

# Disable filename expansion (globbing) so wildcard patterns with * are passed
# to `find` unchanged. We'll re-enable it after the find commands.
set -f

# Create temporary files to store key-value pairs
tmp_keys=$(mktemp)
tmp_values=$(mktemp)

# Cleanup function
cleanup() {
    rm -f "$tmp_keys" "$tmp_values"
}
trap cleanup EXIT

# Function to process env file and update variables
process_env_file() {
    while IFS= read -r line || [ -n "$line" ]; do
        # Skip comments and empty lines
        if [[ $line =~ ^[[:space:]]*# ]] || [[ -z $line ]]; then
            continue
        fi
        
        # Split on first = only
        if [[ $line =~ ^([^=]+)=(.*)$ ]]; then
            key="${BASH_REMATCH[1]}"
            value="${BASH_REMATCH[2]}"
            
            # Trim whitespace
            key=$(echo "$key" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
            
            # Store key and value in temporary files
            echo "$key" >> "$tmp_keys"
            echo "$value" >> "$tmp_values"
        fi
    done < "$1"
}

# Find and process base env files
base_files=$(find . -name "*.env" -not -path "./.env" -not -path "./override/*" ${FIND_EXCLUDE_ARGS[@]})
for file in $base_files; do
    process_env_file "$file"
done

# Process override files if they exist
if [ -d "override" ]; then
    override_files=$(find ./override -name "*.env" ${FIND_EXCLUDE_ARGS[@]})
    for file in $override_files; do
        process_env_file "$file"
    done
fi

# Re-enable filename expansion
set +f

# Write output file
printf "#\n# Do not edit this file. It is generated!\n#\n" > $ENV_GEN_FILE

# Combine keys and values so that later occurrences overwrite earlier ones.
# We read the stream top-to-bottom, storing/overwriting each key. After reading
# all lines we emit the final value for every key and sort for deterministic output.
paste "$tmp_keys" "$tmp_values" \
  | awk -F'\t' 'BEGIN { OFS="\t" } { map[$1] = $2 } END { for (k in map) print k, map[k] }' \
  | sort \
  | while IFS=$'\t' read -r key value; do
    printf "%s=%s\n" "$key" "$value" >> $ENV_GEN_FILE
done
